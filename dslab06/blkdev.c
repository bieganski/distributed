#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>

#include <linux/genhd.h>
#include <linux/fs.h>
#include <linux/blkdev.h>
#include <linux/bio.h>
#include <linux/vmalloc.h>

MODULE_DESCRIPTION("Simple RAM Disk");
MODULE_AUTHOR("N.N.");
MODULE_LICENSE("Dual MIT/GPL");

// This major ought to be free.
#define RDC_BLOCK_MAJOR		240
#define RDC_BLKDEV_NAME		"rdc"
#define RDC_BLOCK_MINORS		1
// Number of blocks of data.
#define NR_SECTORS		2048

// Size of the blocks of data on the device.
#define KERNEL_SECTOR_SIZE	512

/* Global description of a single ram disc. */
static struct rdc_dev {
    spinlock_t lock;
    struct request_queue *queue;
    struct gendisk *gd;
    u8 *data;
    size_t size;
} g_dev;

/* Open - does nothing for ram disk. Real hardware could require some action here. */
static int rdc_open(struct block_device *bdev, fmode_t mode)
{
    return 0;
}

/* Last close of a block device. */
static void rdc_release(struct gendisk *gd, fmode_t mode)
{
}

/* Block operations are a bit different - there is ioctl, which is a sink of operations - no
 * lseek, read or write. However, you can open block devices from userspace - kernel
 * provides a wrapper around performing standard file operations on them. */
static const struct block_device_operations rdc_ops = {
        .owner = THIS_MODULE,
        .open = rdc_open,
        .release = rdc_release
};

/* Main transferring - iterates over parts of the block device request. */
static void rdc_xfer_request(struct rdc_dev *dev, struct request *req)
{
    struct bio_vec bvec;
    struct req_iterator iter;

    // This is a macro, which calls a block of code for every bio_vec from request.
    // Information about buffers stored in `req` structure are extracted to `bvec`
    // and `iter` variables.
    rq_for_each_segment(bvec, req, iter) {
        sector_t sector = iter.iter.bi_sector;
        /* Offset in the kernel buffer, in bytes. */
        unsigned long offset = bvec.bv_offset;
        /* Length of the data transfer in bytes. */
        size_t len = bvec.bv_len;
        /* Direction of data transfer, dir == 1 is write, dir == 0 is read from
         * the perspective of the device. */
        int dir = bio_data_dir(iter.bio);

        if (sector >= NR_SECTORS) {
            printk(KERN_DEBUG "trying to read from too far sector! abandoning request...");
            return;
        }

        /* Kernel buffer for data - it has to be moved in or out of the device. */
        char *buffer = kmap_atomic(bvec.bv_page);

        /* Kmap is a function which maps a physical page of ram, so that it can be used.
         * Atomic means it is fast, and can only be used in context which do not suspend
         * the thread of execution - like waiting for a mutex. Later such memory must be
         * unmapped. */
        
        if (dir == 1) {
            // driver writes
            printk(KERN_DEBUG "blkdev: writing %d", len);
            memcpy(buffer + offset, dev->data + (sector * KERNEL_SECTOR_SIZE), len);
        } else {
            // driver reads
            printk(KERN_DEBUG "blkdev: reading %d", len);
            memcpy(dev->data + (sector * KERNEL_SECTOR_SIZE), buffer + offset, len);
        }

        /* TODO: data needs to be actually transferred to/from `buffer` and `dev->data`.
         * All buffers are in kernel space, so special copy_* methods are necessary. */

        kunmap_atomic(buffer);
    }
}

/* Main entry point of a block device - called when kernel
 * thinks your driver has to make progress on transferring data. */
static void rdc_request(struct request_queue *q)
{
    struct request *rq;
    struct rdc_dev *dev = q->queuedata;

    /* Our device is simple, and so is the driver. We loop over requests. */
    while (1) {
        rq = blk_fetch_request(q);
        if (rq == NULL)
            break;

        // The following method returns 0 for requests generated by the filesystem.
        // So we filter non-fs requests here.
        if (blk_rq_is_passthrough(rq)) {
            printk(KERN_NOTICE "Skip non-fs request\n");
            __blk_end_request_all(rq, -EIO);
            continue;
        }

        rdc_xfer_request(dev, rq);

        __blk_end_request_all(rq, 0);
    }
}

/* Creation of ram disk device. */
static int create_block_device(struct rdc_dev *dev)
{
    int err;

    dev->size = NR_SECTORS * KERNEL_SECTOR_SIZE;

    dev->data = vmalloc(NR_SECTORS * KERNEL_SECTOR_SIZE);
    if (dev->data == NULL) {
        panic("[blkdev] ERROR: VMALLOC FAILED");
    } else {
        printk(KERN_DEBUG "[blkdev] allocating data...");
    }

    /* Initialize the I/O queue. */
    spin_lock_init(&dev->lock);
    dev->queue = blk_init_queue(rdc_request, &dev->lock);
    if (dev->queue == NULL) {
        printk(KERN_ERR "blk_init_queue: out of memory\n");
        err = -ENOMEM;
        goto out_blk_init;
    }
    blk_queue_logical_block_size(dev->queue, KERNEL_SECTOR_SIZE);
    dev->queue->queuedata = dev;

    /* Initialize the gendisk structure. */
    dev->gd = alloc_disk(RDC_BLOCK_MINORS);
    if (!dev->gd) {
        printk(KERN_ERR "alloc_disk: failure\n");
        err = -ENOMEM;
        goto out_alloc_disk;
    }

    dev->gd->major = RDC_BLOCK_MAJOR;
    dev->gd->first_minor = 0;
    dev->gd->fops = &rdc_ops;
    dev->gd->queue = dev->queue;
    dev->gd->private_data = dev;
    snprintf(dev->gd->disk_name, DISK_NAME_LEN, RDC_BLKDEV_NAME);
    set_capacity(dev->gd, NR_SECTORS);

    add_disk(dev->gd);

    return 0;

    out_alloc_disk:
    blk_cleanup_queue(dev->queue);
    out_blk_init:
    return err;
}

static int __init rdc_init(void)
{
    int err = 0;

    err = register_blkdev(RDC_BLOCK_MAJOR, RDC_BLKDEV_NAME);
    if (err < 0) {
        printk(KERN_ERR "register_blkdev: unable to register\n");
        return err;
    }

    err = create_block_device(&g_dev);
    if (err < 0)
        goto out;

    return 0;

    out:
    unregister_blkdev(RDC_BLOCK_MAJOR, RDC_BLKDEV_NAME);
    return err;
}

static void delete_rdc(struct rdc_dev *dev)
{
    // Removing disc structure.
    if (dev->gd) {
        del_gendisk(dev->gd);
        put_disk(dev->gd);
    }
    // Removing the queue.
    if (dev->queue)
        blk_cleanup_queue(dev->queue);
    /* TODO cleanup allocated data */

    printk(KERN_DEBUG "[blkdev] cleaning allocated data...");
    vfree(dev->data);
}

static void __exit rdc_exit(void)
{
    delete_rdc(&g_dev);
    unregister_blkdev(RDC_BLOCK_MAJOR, RDC_BLKDEV_NAME);
}

module_init(rdc_init);
module_exit(rdc_exit);
